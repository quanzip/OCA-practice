Package statement luôn đứng đầu, sau mới đến import statement
Thông thường khi khai báo class, 1 file chỉ chứa 1 public class ở level vao nhất, hoặc là default (package-private không được khác 2 giá trị này)
Chỉ class con mới có thể là static class. và nó cũng có thể là private, public,...

Java.lang.Error la Exception ke thua Throwable => checked Ex.

* thú tự ưu tiên gọi các phương thức nạp chồng overloading: Nếu param là 1 số Integer thì thứ tự các PT nạp chồng có param như sau:  INteger/int -> long ->  Integer.../int.../long...

Exception E= null;
throw E => nullPointerEx; => compile ok

Exception E= new Exception();, sout(E) => java.Exception: E.message

* - Tiếp đó là giới hạn truy cập của @override ở class con không được hẹp hơn, ít nhất là bằng hoặc mở hơn so với phương thức gốc ở class cha.
 * => abstract class đã có abstract thì không kèm final/private
 * nếu phương thức cha là package private, thì class con cũng phải ở cùng package với cha mới có thể override
 * - Checked exception phương thức @Override ở class con không thể throw nhiều và exception mở hơn so với phương thức gốc ở class cha.
  - Chỉ có thể throw nhiều hơn nếu pt gốc và pt override throw exception là cả cha và con (con là ko cần thiết) thì ở phương thức gốc có thể bỏ bớt exception của con, có
  vd nếu ở pt gốc đang throw cả 2 là IOException và fileNotfoundExcetion  thì có thể bỏ fileNotFoundEx, nhưng ở override pt vẫn có thể giữ, nhưng lại không thể throw thêm như Exception vì ở class gốc ko có

        int[] x = new int[0]; // ok
        int[][] b = null;  // ok
        int c[] = null;    // ok
//        int d = null;   // error
//        long l = null;  // error
Các kiểu primative int, long, short,,, đơn khôg thể gán null, phải gán giá trị. Nếu là global var hoặc là khai báo 1 mảng int[10] sẽ được tự động gán là 0, 0.0,.., tương tự với các pt của mảng sẽ được tự cast nếu gán cho khác loại vd: long x = 'c' => ok.
Nhưng có thể gán kiểu mảng private int[] hay long [][]  cho null., khi truy cập vào các element này sẽ văng null pointer ex

protected void getInfo() throws IOException, FileNotFoundException, IllegalArgumentException {
    // throw cha kèm con: ok
}

Lợi ích của polimorphism (đa hình):
Code sử dụng lại được (reuseable), Bảo trì dễ hơn (maintenance)

  int[]bai1, bai2[];
          int bai3[];
          int[] bai4[];
          bai1 = new int[]{1, 2}; // 1 chieu   // day la khoi tao gia tri sau khi khai bao,
          // khi khai bao khong khoi tao luon se phai lam nhu nay, neu khoi tao luc khai bao thi co the bai1 = {1,2}

trong 1 class, instance var là các biến ko phải static, class variable là các biến static

finally block is always executed (Only exception is System.exit();)
Class Exception la checked Ex, Nên khi throw new Exception thì phải try-catch, try-catch nếu có finally có return trong finally thì bên trong try-catch có văng ra new Exception cũng ko cần bắt vì nó còn đi vào finally và return ở finallythì
, nếu finally văng thì phải khai báo try-catch hoặc khai báo trên method signature, hoặc nếu finally không có return thì throw checkeex ở trong catch ra cũng phải try-catch

//  vì finally luôn được chạy nên:  nếu trong try có return nhưng finaly không có return thì return vẫn chạy nhưng trả kết quả là từ return của try
            // Nếu try/catch/finally đều có return thì method sẽ lấy giá trị return của finally
Chỉ có thể khai khối trycatch của checked exception khi mà code trong try có nguy cơ văng checkedExcoeion. nếu ko, ko được khai  try catch(Checked ex)
Còn ở method signature thì có thể khai throws checkedEx/unchecked ex mà trong body không cần văng ra gì.

class PortConnector {
    public PortConnector(int port) throws IOException { // có thể khai throw ex ở constructor signature

QuANTRONG
khi mà class chỉ có các kiểu primative hoặc các kiểu wrapper của chúng thì sẽ không có các import cụ thể, JVM tự import các import sau: 1.Java lang,2.The package with no name.
=> tất cả các đối tượng mà từ pkg java.lang và các package noName thì sẽ không cần import tường minh, jvm tự động import khi biên dịch

  int []i = {1,2,2}; i.getClass().isArray() => true; cũng đúng với các kiểu khác như Object...

// khi đã khai thuộc tính final thì phải gán giá trị ngay hoặc
     // phải gán trong constructor hoặc trong static block

Thuộc tính protected dùng cho class con(ở bất kỳ đâu) hoặc trong cùng package (k được kể cả trong package con.)
Implement chuẩn đóng gói sẽ là các thuộc tính phải để private, các PT get set phải để public hoặc protected

Nếu chỉ rõ khai báo 1 object từ đâu bắt đàu bằng package name gốc thì ko cần import: util.log4j.Logger log = new util.log4j.Logger() => ko cần import gì cả
 Nếu có 2 class trong cùng 1 pkg thì 1 trong 2 class gọi nhau sẽ ko cần import, ok,
* Nếu chúng ở khác pkg thì khi gọi nhau phải có import cự thể.
* Nếu dùng import white card pkg K trong class C để gọi class B, nhưng trong cùng package với C cũng có 1 class tên B khác, thì nó sẽ là ref của B trong cùng pkg với C (k ưu tiên white card)

Nếu nạp chồng method mà có 1 method có param int ...X và 1 method có param long x thì khi truyền 1 vào sẽ ăn vào phương thức có long là param.  truyền mảng mới ăn phương thức kia.

/*
* Khi khai báo String với new String("ok")  thì sẽ có 2 object được khởi tạo
* 1. new String("ok") là khởi tạo 1 object nên sẽ được lưu ở trong heap.
* 2. với mệnh đề: "All literal string are interned" => Tất cả các chuỗi string đều được lưu ỏ string pool, khi lưu, check xem cso chưa, chưa có mới lưu mới. Do vậy "ok" cũng sẽ được check và tạo mới ở trong pool
    với String s = new String("ok);  và String s1 = "ok"   thì sẽ có 2 Object được tạo, đối tượng s đầu tiên tạo 2 Object này, 1 ở heap, 1 ở pool, đối tượng s1 tạo thì kiểm tra pool đã có "ok" rồi nên lấy ra dùng luôn
    * Nhưng 2 object trên là khác nhau (trỏ vào 2 vùng nhớ khác nhau) nên khi so sánh thì == SẼ TRẢ FALSE, còn dùng EQUALS SẼ TRẢ TRUE;
* * */

  * String buffer is thread-safe, its method are synconized.
    * // size khởi tạo của 1 String buffer là 16, nếu length vượt quá, nó sẽ tăng lần dần dần với 16
    * */
String dd = "quan";
        String ff = "qua";
        ff = ff+ "n";
        System.out.println(dd == ff); // false


 interface sẽ extends interface
 abstract class sẽ implements interface (không được extends, và không cần implements abstract methods.)
Abstract class/ class normal khai static method, static method có thể được gọi bằng instanceic --
Interface khai static method, thì static method này chỉ có thể được gọi bằng refernce (InterfaceName.methodName)
=> A extends ABSTRACT CLASS implement INTERFACE thì A là thể hiện (instance của abstract class), và A chỉ là triển khai của Interface chứ A không phải là thể hiện (instance) của interface
=> Nếu abs class C và interface D cùng có 1 phương thức static S, thì khi khai íntance A a = new A,  a.S là sẽ gọi phương thức của abs class C,
chứ ko gọi S của inteface D bởi vì class có thể gọi phương thức static bằng instace của nó,   nhưng interface thì không

/*
* Dùng phương thức non static để kế thừa 1 phương thức static là không được và ngược lại, tức là cha và con có cùng 1 phương thức, có quan hệ kế thừa.
  trường hợp đặc biệt: Khi interfa có phương static X, Và được interface B kế thừa thì B có thể khai X với default (non-static)
 */

 class Animal1 {
     static String name;
      int numLeg;

     public Animal1() {
         this(name, numLeg);    // errror vì numleg không phải static => trong this([args]) thì các args phải là static var/methods.
     }
    => Muốn sử dụng THIS(var, var1) với các biến, thì các biến đó phải là static

 boolean a1 = false;
        boolean b1= true;
        boolean c1 = a1 && (b1 = false); //  because a1 = false; so right hand value (b1 = false) is not cared anynore
        // so c get false as result
        System.out.println(c1);  // false;
        System.out.println("AND:" + a1 + "-" + b1); // false true


// Trong biểu thức này, vẫn áp dụng theo quy tắc bên trên, đằng sau toán tử đôi (+=) luôn được đặt trong ngoặc
        // và thực hiện trước. Tuy nhiên, biểu thức (l=3) sẽ gán giá trị cho l, nhưng tại chỗ gán đó l mới có giá trị mới,
        // những chỗ truóc đó l xuất hiện thì vẫn mang giá trị cũ như ban đầu gán.
        long l = 4;
        l += 2 * l + (l = 3) * 3; // 4 + ((2 * 4) + 3 * 3) = 21;
        System.out.println(l);

logic operation (&&, ||)  ###  bitwise operation (& | ^):
logic: break circuit when 1 side is nok while bitwise will run throughout business even 1 side is not ok
// new knowledge: XOR ~ ^: require only one side to be true => true; if both is false or both is true => false;
        // XOR là toán tử yêu cầu 1 trong 2 vế phải là true thì KQ trả ra sẽ là true, còn các Th khác sẽ là false;
        // vd 1 true 1 false -> true, 2 true -> false, 2 false -> fasle;
        boolean r = 1 > 2 ^ 2 > 1; //  false ^ true => true;
        boolean r1 = 1 < 2 ^ 2 < 3; // true ^ true  => false;
        boolean r2 = 1 > 2 ^ 2 > 3; // false ^ false => false;
        System.out.println("XOR: " + r + "-" + r1  + "-" + r2);

- Chỉ có thể đặt class là static nếu đó là 1 subclass (class conv được khai báo bên trong của class bất kỳ)
- Khi khởi tạo instance của 1 static class D là 1 class con của class X. ta chỉ cần X.D className = new X.D();
Nhưng nếu D là 1 normal class (non static): Thì cần khởi tạo Class X trước, sau đó dựa vào X để khởi tạo D: X x= new X; X.D className = x.new D();

/**
     * ok
     */
    public void EmptyClass() {
        System.out.println("This method has same name with class but it is not a constructor and still valid");
    }

 /*
        * Object luôn được khai báo và định giá trị tại run-time, kể cả khi chúng được khai báo final.
        primative type sẽ được định giá trị tại compile time nếu chúng được khai báo final.
        * */

 for (int m = 0; m++<10 ;){   =>> m sẽ so sánh với 10 xong rồi mới cộng thêm 1

 SIC, thứ tự chjay của các thành phần trong 1 class, 3 khối static, instance và constructor sẽ được tự động thực thi sau mỗi lần 1 object được khởi tạo
 riêng khối static chỉ được chạy 1 lần ở lần khai báo đầu tiên của class.

* while khác do-while ở chỗ:
* while chỉ lặp nếu biểu thức điều kiện ok
* Do-while sẽ thực thi ít nhất 1 lần, ở những lần lặp tiếp theo, sẽ phụ thuộc vào điều kiện ủa while trả ra, cần chú ý vị trí thay đổi điều kiện ex: do{}while(i++<10) thì i sẽ so sánh với 10 trước rồi mới cộng thêm 1
== Khi dùng label, có thể dùng cho 1 lệnh bất kỳ ex (OK:sout("quan")), nhưng không thể dùng break/continue cho cho các lệnh này, vì chúng không đại diện cho 1 loop.
điều kiện của if(false), do{}while(false) có thể để cứng là false => ok, nhưng với while(false) và for(;false;) sẽ compile error.  for(;;) -> ok, nếu điều kiện xác định từ non-final var, thì vẫn sẽ ok vì JVM sẽ valuate at runtime
for(;true;) hay while(true){} => ok
if (1==20) {}// ok

----------------switch
 // Các giá trị trong case phải trong khoảng giá trị cho phép của kiểu truyền vào trong switch - phải được xác định ngay lúc compile(khi viết mã)
        // default case có thể đặt tại bát cứ đâu.
        // Các kiểu có thể dùng: int short byte char string, enum và các kiểu wrappẻ của chúng.
        // Nếu không sử dụng break ở mỗi case, thì khi switch chạy, case X có giá trị thỏa mãn, thì tất cả các logic
        // từ X trở xuống, bao gồm logic của các case khác cũng được xử lý mặc dù giá trị của case là không khớp
        // và bao gồm cả logic của DEFAULT nếu default để phía dưới case đó. Sẽ chạy đến khi nào gặp break
        // Nếu để default ở trên đầu, các case phía dưới ko có break, ko match case nào => ăn vào default và tất cả các case phía dưới bởi defualt ko có break và các case cũng ko có break;
        //
        // ex
        // Trong ví dụ dưới. các case không có break, case: 1 không thỏa mãn, logic của nó không được chạy
        // và case 2: sẽ thỏa mãn, thì logic của nó và logic của case 0 sẽ được thực thi do case 2 không có break
        // DEFAULT không được thực thi do default được đặt trên đầu, nếu nó dược đặt dưới case 2, nó cũng sẽ được thực thibreak cho đến khi gặp b

-------- mảng
mảng luôn được lưu trữ tại heap, kể cả mảng của các kiểu nguyên thủy hay kiểu object
Mảng 1 chiều kiểu primative thực chất là 1 đối tượng nên chỉ có thể gán cho đối tượng object. Object c = new short[]{1} // ok
Mảng 1 chiều kiểu primative vì vậy không thể gán cho mảng object[]
Mảng 2 chiều kiểu primative là mảng 1 chiều, mỗi phần tử là 1 hàng nên có thể gán cho mảng 1 chiều object[]
 +++ Khi đếm các đối tượng đã được tạo ra là bao nhiêu, phải đếm tất cả các dối tượng có , bất kể đã gán null hay chưa.
  * Khi khai báo Integer x[]= {1,2,3} hoặc dùng phương thức valueof(X) thì X sẽ được kiểm tra trong cache có chưa, có rồi thì dùng, chưa có thì thêm vào cache thay cho phương thức new Integer(X).
  vd Integer X[] = {1,2,3,4}
  *  Integer Y[] = {1,2,3,4}
  *  thì có 6 đối tượng được tạo ra, có các phần tử trong Y đều đã được cahe và dùng lại
  *   => X[0] == Y[0]   =>  true.
với kiểu string và các kiểu custom khác thì mảng 1 chiều chính là mảng object, Object []o = new String[]{};  //ok

----- Stack - heap - gc
 System.gc(); // suggest JVm to reclaim memory
Kind kind = new Kind("data");
// in stack  // data of kind is saved in heap
kiểu primitive và reference của object sẽ được lưu ở stack (high speed), data của object sẽ được lưu ở heap
Nếu 1 biến được khai báo sau đó sử dụng, sau đó được gán lại về null, thì tại dòng null đó, biến đó là đủ điều kiện để GC thu dọn

-------------- enum
Enum
Enum có thể sử dụng == or equals() để so sánh
Không thể kế thừa bất kỳ thứ gì(interface, class, abstract class), có thể có constructor,  fields, METHODS.
Constructor sẽ ngầm định là private, không được chuyển sang public | protected. do vậy chỉ có thẻ gọi constructor của nó bên trong chính nó. Cũng do đó không thể kế thừa enum, không thể khai báo enum với từ khóa new.
Các giá trị của enum đưuọc đánh thứ tự, bắt đầu từ 0 ^, Enum là type kế thừa java enum. KHÔNG PHẢI KIỂU PRIVATIVE nên không thể so sánh giá trị với int ie if(enumVar == 4) // error

Vào lần sử dụng đầu tiên của bất kỳ enum reference nào. tất cả các thành phần đều sẽ được khởi tạo theo trong lần đó, kể từ đó về sau, nếu các enum khác được gọi, JVm sẽ chỉ cần return các enum đã được khởi tạo đó => JVm chỉ khởi tạo các enum duy nhất 1 lần,
Trong enum có các method, các method là chung cho tất cả các reference, được sử dụng bởi các instance.  Nếu bất kỳ thành viên của enum muốn có riêng thêm hoặc overide lại method chung, thì khai báo trong body riêng của chúng. Nhớ phải có ; ở cuối {};
Instance của enum có thể gọi các method chúng. không thể gọi các method riêng bởi vì khi khai báo là EnumType name = EnumType.Xvalue nên instance này chỉ gọi được các method chung.
Nếu enum khai báo phương thức trừu tượng (có từ khác abstract) thì tất cả các thành viên phải overide lại method này

1 Phương thức có thể throw bất kỳ ex nào ở signature, mà trong body không có rủi ro throw hoặc body không throw gì cả

trong câu hỏi đoạn code chạy sẽ in ra cái gì:
Để ý các đáp án có thể đúng 1 phần => vẫn coi là đúng. vis dụ, toàn luồng in ra A B C D
thì câu trả lời đúng có thể là : in ra A B in that order hoặc The program will print A => đúng

There is a java.lang.OutOfMemoryError but no MemoryException. There is also a java.lang.StackOverflowError.

--------------- Exception
/*
* Try-with-resource luôn có 1 finally block ngầm định java sẽ chạy để đóng các tài nguyên trong try
* Nếu ta khai báo tường minh 1 finally block, java vẫn sẽ chạy finally block ngầm định trước tiên, sau mới đến finally block của ta khai báo.
* Try-with-resource vẫn có quy tắc như try bình thường, vẫn yêu cầu phải có catch hoặc finally hoặc cả 2. Nhưng vì luôn có 1 finally ngầm định nên ta không cần catch/finally nữa với try-with-resource. Chỉ cần duy nhất try(){} mà thôi
* Các tài nguyên khai báo sau của try-with-resource sẽ được đóng trước, theo thứ tự từ phải sang trái. chỉ những tài nguyên khai báo trong try-with-resource () mới có thể tự động được close
* Tài nguyên trong try-with-resource () và body của nó {} là local, không thể sử dụng tại catch hoặc finally tự định nghĩa,
nếu Nếu trong try-with-resource throw Ex, thì nó sẽ trở thành main exception và được xu lý bằng Ex của catch(Exception mainEx) {} còn các exception mà bị văng ra từ finally {} ngầm định sẽ được nén vào trong 1 array, lấy ra từ mainException.getSuppressed();
* */
Khi kế thừa phương thức có signature with exception
// throws FileNotFoundException   -> ok, nhỏ hơn cha.
        // throw RuntimeException ->  ok vì là RuntimeException
        //
        // throw Exception() -> not ok -> checked exception lớn hơn cha.
        // throw SqlException -> not ok -> checked Exception không cùng cây với cha.
        /*
        * COn chỉ có thể throw Exception giống hoặc là con nhỏ hơn cha,
        * - hoặc không throw gì
        * - hoặc throw bất kỳ runtime exception
        *
        * Con không được throw Checked exception khác loại mà không cùng cây kế thừa với cha
        * Con Không được throw ex cùng cây kế thừa với cha nhưng lớn hơn của cha.
        * */
- 1 khối try catch, các khối catch sẽ được khai ex tùy ý nếu chúng là runtimeEx theo chiều tăng dần phạm vi (con -> cha)
Chỉ được khai catch là checked EX nếu phương thức trong try{} văng ra ex đó.

Kế Thừa:
Nếu A kế thừa B, B định nghĩa cons tường minh CÓ THAM SỐ,  thì A cũng phải override (gọi) phương thức này trong cons của A
=> Tất cả class kế thừa B đều phải khai cons và gọi tới cons có tham số của B
=> Nếu B không khai bất kỳ cons nào thì các con có thể khai hoặc không.
=> Nếu B khai Cons không tham số thì các con có thể khai hoặc không
=> Nếu B khai Cons có tham số thì các con bắt buộc phải khai cons và gọi cons của B (chỉ cần 1 trong các cons của B, nếu B có nhiều)

Interface
Mặc định biến trong interface luôn là public static final, không thể that đổi được giá trị
Nếu khai báo phương thức static S và method Default D
- Static method của interface chỉ có thể gọi qua reference (interfaceName.staticMethod), không thể gọi qua interface instance, còn static của class và abs class có thể được gọi qua reference hoặc instance.
- Default method có thể gọi qua instace, không thể gọi qua instace,  class triển khai insterface phải khai báo instace để gọi các default method này
=> Static method và default method của interface có quy tắc truy cập ngược nhau.
=> Khi A kế thừa abs class B và interface C, B và C đều khai phương thức static S,
a.S là gọi S của B vì static method S của Class và abs class mới có thể gọi qua instance,  Static method của interface C chỉ cso thể được gọi qua referenceName
Class static Phải là class con, và cos thể được extends bởi class khác, phương thưc static thì

d instanceof C
Nếu C không phải là cha hay ông nội (tính cả extends hay kế thừa) thì compile sẽ lỗi luôn, không biên dịch.
Tương tự với ép kiểu, nếu không trong cây kế thừa sẽ lỗi luôn compile, còn trong cây rồi thì có thể compile nhưng runtime vẫn có thể lỗi do không thể casst

RETURNTYPE => double, vì long < double của d nên  giá trị chung trả ra sẽ là kiểu double
public RETURNTYPE methodX( byte by){
    double d = 10.0;
    return (long) by/d*3;
}
// Khi cast (long) thì chỉ là cast cho vế đầu , tương đương với ((long) by/d* 3)


FINAL ARGUMENT
 public static final String getInfo(final Go s, final Go d ) {
        return "";
 }
 // final ở tên hàm chỉ có ý nghĩa rằng trong phạm vi hàm đó, các tham số đó sẽ không thể gán lại giá trị
 // khi gọi hàm đó, các tham số không cần phải là final

 package com.oca.TEST_TEST_TEST_TEST_TEST_TEST.test1603;

 public class Sentance9 {

     private final double r;
     // khi đã khai thuộc tính final thì phải gán giá trị ngay hoặc
     // phải gán trong constructor hoặc trong static block
     double rr;
     static {
 //        r = 1;  only if r la static
     }

     Sentance9() {
         r = 1;
     }

     public void setShort(short ddd) {  // short
         rr = ddd;
     }
     public void setRR(long ddd) {   // long
         rr = ddd;
     }

     public static void main(String[] args) {
         Sentance9 e = new Sentance9();
         e.setRR(90);  // ok auto cast  to Long, vi 90 se tu hieu la Int, ma int < long la tham so cua ham => OK

         e.setShort((short)90); // error vi 90 la int, co the vuot qua range kieu short cua ham
         // nen phai cast ve short
     }
 }

 public static void changeString(String s, StringBuilder sb, ObjectR r, int[] is) {
         s = null;
         sb.append("quan");
         sb = null;
 //        sb = sb.append("s");
         r.name = "Asd";
         r = null;

         is[0] = 1;
         is[2] = 3;
         is = null;
 }
 // phuong thuc tren co casc tham so duoc gasn bang null o cuoi, chung deu ko the anh huong den object, sau khi goi phuong thuc tren
 // casc object goc van co gia tri nhu binh thuong, ko bi null di da bi gan null,  casc data dc thay doi trong method deu dc ghi lai

 // java dung co che callByValue de goi ham: truyen vao 1 ban copy X cua cac object goc G de thuc thi tren do, neu thay doi thuoc tinh thi ca 2 se bi thay doi
 // , nhung neu ben trong ham ma object bi gan sang 1 doi tuong khac K, thi X se tro sang 1 vung nho khac, G van la G, luc nay rieng biet han vs X, khong bi gan sang K
 // truoc khi gan sang K, neu X thay doi gia tri thuoc tinh thi ca X va G deu dc thay doi nhu nhau do van con tro chung vao 1 vung nho data

--------- String
Đối với string , mọi string đều được intern (đưa vào trong pool), và có thể dùng để + giá trịkhác string khác khi chúng đang bị null, lúc nào giá trị sẽ kèm thêm chuỗi null
vd string s = null;   s+="quan"  =>   "nullquan"  mà không có exception. với các kiểu khác, sẽ bị null, ngay cả với kiểu Integer, Float hay Long, khi khai báo bằng null mà sử dụng, sẽ có exception null pointer
Khi khai báo String s = "quan"; String g = "quan", if (s == g) => true, String h = "qua" + "n", if (h == g) => true NHUNG  string ff = h + "n", if (ff==s) => false

--------- Kế thừa và thứ tự thực thi bên trong constructor SIC
/*
* Khi 1 class khai báo, trong constructor của nó các thành phần sẽ chạy theo thứ tự SIC: super(), instance initializer, phần còn lại của constructor.
* ở ví dụ dưới, sẽ được thực thi như sau:
* 1. JVM thấy A có constructor no-arg nhưng chưa gọi supẻr() ở trong nên Jvm tự thêm super() vào constructor no-arg này.
* 2. Jvm thấy BB không có cons => tự thêm cho BB no-ảrg cons và chèn super() vào bên trong
* 3. trong hàm main, sau khi khởi tạo BB, cons của BB sẽ được chạy theo trình tự SIC (call super(), chạy instance {} của BB, các logic còn lại trong constructor của BB)
* ---- thực thi khởi tạo A bên trong Cons của A:
* lệnh gọi super() sẽ được hạy đầu tiên => no-arg cons của A sẽ được chạy trước. Tại đây, gặp lệnh super() => gọi tới no-arg cons của class Object, khởi tạo xong instance Object, sau đó sẽ khởi tạo các biến/var bên trong class Object => complete class Object
* +++++++tiếp theo sẽ đi khởi tạo giá trị các var trong A, lúc này là I, non-final => định giá trị tại runtime là 10,
* +++++++Tiếp theo các thứ còn lại trong no-arg cons của A, lúc này là func print(). Phương thức này được kế thừa bởi BB vì BB cũng có print() và có cùng signature nên phải kế thừa của A, nếu khai báo print trong BB có signature khác print() trong A, thì vẫn ok, sẽ là overloading không phải overriding
* Bởi vì khi gọi method thì sẽ là gọi method của instance nên print() sẽ được gọi của BB đã override. Khi chạy print có sd var I của BB, nhưng lúc này I chưa được khởi tạo giá trị(evaluate at runtime, non-final) nên có giá trì là 0. vì đây mới đang trong bước khởi tạo A, chưa chạy đến bước var initialization của BB
*  => print() của B sẽ in ra 0. Sau đó chạy tới func aFunc(), là phương thức k đc kế thừa nên sẽ gọi phương thức aFunc của chính nó, in ra afunc, Lúc này đã chạy xong  hàm super() trong cons của BB
*
*
*  ---- Khởi tại gía trị các biến trong BB (var initialization BB) sau khi chạy super()
 *   ++ Đầu tiên là gán giá trị cho I = 4, vì nó là runtime var nên bây giờ mới đướj gán giá trị, nếu khai báo là final thì JVM lúc compile đã định dẵn giá trị rồi
 *   ++ Tiếp theo là chạy lệnh a.print(), phương thức này đã được kế thừa bởi BB, nên sẽ là instance method => chạy bằng print() của BB., có sử dụng I đã được khởi tạo giá trị bước trên: 4
 *   ++ tiếp theo là chạy lệnh in ra a.I,   cả A và BB kế thùa A đều có biến này và đã có giá trị, Nhưng biến thì luôn là reference variable nên sẽ truy cập và sử dụng biến của A => in ra 10
 *
 * Như vậy sau toàn bộ qúa trình hàm main sẽ in ra: 0 aFunc 4 10
* */


class A {
    int i = 10;
    public A() {
        print();
        aFunc();
    }

    public void print(){
        System.out.print("A ");

    }

    public void aFunc() {
        System.out.println("Afunc");
    }
}
public class BB extends A{
    int i =4;
    public static void main(String[] args) {
        A a = new BB();
        a.print(); // instance method
        System.out.println(a.i);  // reference variable
    }

    public void print() {
        System.out.print(i + " ");
    }
}

------------------- Static var, static block
/*
* Nếu A kế thùa B, B có biến static, A có thể sử dụng biến này trữ tiếp thông qua tên của A: A.staticVarName, hoặc sử
* dụng thông qua instance của A,   a.staticVarName
* */
public class Bai8 {
    public static void main(String[] args) {
//        Sub sub = new Sub();
        System.out.println(Sub.ID);  // via reference ok
//        System.out.println(sub.ID);  // via instance ok
    }
}
class Super {
    static { System.out.print("In Qbank");};
    {
        System.out.println("Instance block");
    }
    static String ID = " ID"; }   // nếu như khai báo final, Giá trị này sẽ được gán ở lúc Compile time và Jmv biết nó sẽ không bị thay đổi
   // Cho nên ở hàm main khi truy cập vào ID này, JVM biết giá trị nó rồi
// sẽ không dẫn đến sự Load của class Super trong bộ nhớ => block static sẽ không được chạy
   // Nhưng nếu var ID này không để final, thì ở hàm main lúc gọi đến field static này, thì nó mới được gán giá trị  = "ID"
// => Class Super sẽ được load vào bộ nhớ => block static sẽ được chạy vào lúc này
    /* result:
    * Class Super sẽ được JVM load vào bộ nhớ (đồng thời chạy các static block) khi xảy ra bất kỳ điều gì sau đây:
    *  1.Class được khởi tạo với từ khóa new
    *  2. Bất kỳ Phương thức static của class được gọi lần đầu
    *  3. Bất kỳ biến static nào được gán giá trị lần đầu => biến đó không phải final
    *  4. bất kỳ biến static nào được GỌI lần đầu và biến đó không phải final (non-final thì lúc này gọi JVM mới load giá trị => load class, còn nếu biến static này là final thì JVM biết rõ giá trị nó ròi, có được gọi thì class cũng không được loadd)
    *  5. bất kỳ biến static nào điuọc gọi lần đầu  thông qua class/interface con
    *  6. bất kỳ method thường/static nào được gọi thông qua method reflection của  class Class hoặc package java.lang.reflect
    * */

class Sub extends Super{
    static final int t = 10;
    static { System.out.print("In Sub");  // AAA   static block chỉ được thực thi khi mà 1 trong các sự kiện bên trên xuất hiện }
        {
            System.out.println("Super instance block");
            // khối instance block chỉ được thực thi khi class được khai báo với keywỏrd NEWnhớ, chi chạy duy nhất 1 lần khi class được load
            // , còn khối static sẽ được thực thi khi mà class được load vào trong bộ, chạy nhiều lần mỗi khi class Object được khởi tạo
        }
}

----------------- getClass => getClass instance
AA a = new BB();
        System.out.println(a.getClass());  // BB

----------------- IF
int g = 4;
if (g-->4){   // if (10-->4)  => invalid because 10 must be var like G

}


------------- mảng 2 chiều
 int [][]i = {{1,2}, {1,3,4}};
        System.out.println(i);

i[2]= new int[]{4, 5, 6, 7}; // error,  Khi đã khai báo int [][]i = {{1,2}, 4{1,3,4}}; là đã gán cứng size của mảng 2 chiều là 2 hàng 3 cột, không thể thêm.

// để ý câu hroi
Which of the following code fragments will successfully initialize a two-dimensional array of chars named cA with a size such that cA[2][3] refers to a valid element?

// ásk
Consider: o1 and o2 denote two object references to two different objects of the same class. Which of the following statements are true?
Lựa chọn của bạn đúng
Nothing can be said about o1.equals(o2) regarding what it will return based on the given information.
o1.equals(o2) will always be false.
o1.hashCode() == o2.hashCode() will always be false.
Nothing can be said about o1 == o2.
Lựa chọn của bạn đúng
o1 == o2 will always be false.